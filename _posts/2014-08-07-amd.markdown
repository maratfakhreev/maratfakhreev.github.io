---
layout: post
title:  "Asynchronous Module Definition (AMD). Using Require.js in Backbone.js application"
date:   2014-08-07
---

The Asynchronous Module Definition API specifies a mechanism for defining modules such that the module and its dependencies can be asynchronously loaded. This is particularly well suited for the browser environment where synchronous loading of modules incurs performance, usability, debugging and cross-domain access problems.

---

# Theory

## CommonJS

CommonJS module is declared quite simply. Namespace organization is performed directly in the module, the modules are being placed separately in different files and provide variables for public use by addition to the special object `exports`, defined in the interpreter.

```javascript
//math.js
exports.mult = function(value1, value2) {
  return(value1 * value2);
};
//app.js
var Maths = require("./maths");
console.log(Maths.mult(10, 20));
```

To use functions defined in the module, you need to request a file using the `require ()` function, storing the result in the local variable. However CommonJS modules work in the relevant compatible interpreters JavaScript, such as Narwhal and Node.js.

## CommonJS in browsers

Specification described above imposes certain requirements - CommonJS modules must be loaded simultaneously. This requirement is well suited for JavaScript, running on the server side. However, it is problematic for browsers where such an approach would cause problems such as interface blocking.
Therefore CommonJS's team has developed a format specification for  module transportation - module transport module. This format is CommonJS-transfer modules in a callback function to allow asynchronous load on client machines.

```javascript
//math.js
require.define("maths", function(require, exports) {
  exports.mult = function(value1, value2) {
      return(value1 * value 2);
  };
});
//app.js
require.define("application", function(require, exports) {
  var Maths = require("./maths");
  console.log(Maths.mult(10, 20));
}, ["./maths"]); //dependencies enumeration(maths.js)
```

As such, the modules can be claimed by modules loading library and be executed in the browser.

---

# RequireJS

Require.js is an AMD script loader that asynchronously loads your JavaScript to improve page load performance. It also provides the ability to organize your JavaScript into self contained modules. Each JavaScript file represents a module. It is optimized for in-browser use, but it can be used in other JavaScript environments, like Rhino and Node. Using a modular script loader like RequireJS will improve the speed and quality of your code.

## RequireJS modules.

Each module is enclosed in a define tag that lists the moduleâ€™s file dependencies and keeps the global namespace free (essentially acting as a JavaScript closure). Since none of your modules are global, you need to declare inside of each module other modules are dependencies and pass them to your current module. This provides a solution for limiting global variables and dependency management. This solution is much better then having many script tags in a single page, which can be cumbersome to keep track of which files depend on which other files.

***require***

To load JavaScript files,  transfer their path names to function `require ()`, specifying a callback function that will be called when all dependencies are loaded.

```javascript
require(['app/application', 'libs/utils'], function(App, Utils){
   //...
})
```

***define***

To determine the modules in the browser, RequireJS uses a slightly different syntax, unlike standard CommonJS.

```javascript
define(['jquery', 'underscore', 'libs/utils'], function($, _, Utils){
  var obj = {
    //...
  };
  return obj;
})
```

As you can see the variable `exports` is absent, instead a return of function is used. This API can not be used on the server-side, for example in the Node.js environment. However RequireJS has a level that is compatible with CommonJS modules.

```javascript
define(function(require, exports){
  var mod = require('./app/module');
  exports.value = module.getValue();
})
```

---

## Using Require.js in Backbone.js application

This example is based on the construction of application **Backbone base** using language **CoffeeScript**. More here: `github.com/fs/backbone-base`

In the project we have an index.jade and coffeescript modules. The directory layout may look like:

```bash
app
  bower_components
  vendor
  scripts
    collections/
    controllers/
    facades/
    models/
    routers/
    views/
    application.coffee
    config.coffee
  index.jade
```

To take full advantage of the optimization tool, it is suggested that you keep all script tags out of the HTML, and only reference require.js with a require call like so to load your script.

```slim
//index.jade
doctype html
html.no-js
  head
    ...
    script(type='text/javascript', data-main='/scripts/config', src='/bower_components/requirejs/require.js')
  body
    ...
```

### The next step is to create a config file for your application:

+ `baseUrl` indicates an initial path for all files from the *paths*.
+ `deps` indicates a file that serves as the primary initializer of the entire application.
+ `paths` describes the files and directories, which you have access to, and assigns aliases for them.
+ `shim` describes the dependencies for the modules. Since the loading is done asynchronously, it is often required to strictly load some modules (that are used by others) in advance. Therefore, for each module, you can specify `deps` property, which will list dependencies, and specify the variable `exports`, through which methods module will be available.

***Important***. Do not try to use a greater number of dependencies in the option `shim`. Ask only those dependencies that are required throughout the entire application, in other cases dependencies must be passed strictly in the module.

```coffeescript
#scripts/config.coffee
requirejs.config
  baseUrl: '/'
  deps: ['scripts/application']
  paths:
    #bower components
    'backbone': 'bower_components/backbone/backbone'
    'underscore': 'bower_components/underscore/underscore'
    'jquery': 'bower_components/jquery/jquery'
    'marionette': 'bower_components/marionette/lib/backbone.marionette'
    'bootstrap': 'bower_components/bootstrap/dist/js/bootstrap'
    'backbone.routefilter': 'bower_components/backbone-route-filter/backbone-route-filter'
    #vendor
    'jade': 'vendor/scripts/runtime'
    #application
    'views': 'scripts/views'
    'controllers': 'scripts/controllers'
    'routers': 'scripts/routers'
    'models': 'scripts/models'
    'collections': 'scripts/collections'
    'templates': 'scripts/templates'
    'storage': 'scripts/facades/storage'
  shim:
    'marionette':
      deps: ['backbone', 'backbone.routefilter']
      exports: 'Marionette'
    'backbone':
      deps: ['jquery', 'underscore']
      exports: 'Backbone'
    'backbone.routefilter':
      deps: ['backbone']
    'bootstrap':
      deps: ['jquery']
    'templates':
      deps: ['jade']
    'underscore':
      exports: '_'
    'jquery':
      exports: '$'
```

Inside of *application.coffee* you can use `require()` to load any other scripts you need to run. This ensures a single entry point, since the data-main script you specify is loaded asynchronously. Since application.coffee is being an initializer of an application and doesn't return anything, it is advisable to use `require()` instead of `define()`.

```coffeescript
#scripts/application.coffee
require [
  'marionette'
  'routers/main'
], (Marionette, Router) ->

  App = new Marionette.Application()

  App.addInitializer ->
    App.Router = new Router()

  App.on 'initialize:after', ->
    Backbone.history.start
      pushState: true
      root: '/'

    $(document).on 'click', '.js-link', (event) ->
      event.preventDefault()
      href = $(event.currentTarget).attr('href')
      App.Router.navigate(href, trigger: true)

    console.log 'app started'

  App.start()
```

As you can see application.coffee  is using `marionette` and `router` modules to run an application, which in turn have other modules as dependencies.

***Important***. For proper design of modules use the rule **"One module - one entity"**, do not try to define many classes in one module. Part them to modules and connect as dependencies in the `define [...]` body.

```coffeescript
#scripts/routers/main.coffee
define [
  'marionette'
  'controllers/main_controller'
  'models/user_session'
], (Marionette, Controller, UserSession) ->

  class MainRouter extends Marionette.AppRouter
    initialize: ->
      @controller = new Controller
      @listenTo @controller, 'logout', @redirectIfNotLoggedIn
      @listenTo @controller, 'dashboard', @showDashboard

      super

    appRoutes:
      '': 'indexPage'
      'dashboard/': 'showDashboard'
      'dashboard/articles/': 'showArticles'
      'dashboard/articles/:id/': 'showArticle'
      'logout/': 'logout'

    before:
      'dashboard/*path': 'redirectIfNotLoggedIn'

    redirectIfNotLoggedIn: ->
      session = UserSession.getInstance()
      unless session.isLogged()
        @navigate '/', trigger: true
        false

#scripts/controllers/main_controller.coffee
define [
  'marionette'
  'views/layouts/layout'
  'views/layouts/header_layout'
  'views/layouts/articles_layout'
  'views/content/landing'
  'views/articles/show'
  'views/dashboard/dashboard'
  'models/user_session'
  'models/article'
  'collections/dashboard_articles'
  'collections/articles'
], (Marionette, Layout, HeaderLayout, ArticlesLayout, ContentLandingView, ArticlesShowView,
    DashboardView, UserSession, Article, DashboardArticles, Articles) ->

  class MainController extends Marionette.Controller
    initialize: ->
      @layout = new Layout
      @layout.render()
      @layout.headerRegion.show(new HeaderLayout)

    indexPage: ->
      @layout.mainRegion.show(new ContentLandingView)

    logout: ->
      session = UserSession.getInstance()
      session.logout()
      @trigger('logout')

    showDashboard: ->
      articles = new DashboardArticles()
      articles.fetch().then =>
        @layout.mainRegion.show(new DashboardView(collection: articles))

    showArticles: ->
      articles = new Articles()
      articles.fetch().then =>
        @layout.mainRegion.show(new ArticlesLayout(collection: articles))

    showArticle: (id) ->
      model = new Article(id: id)
      model.fetch().then =>
        @layout.mainRegion.show(new ArticlesShowView(model: model))
```

---

## Why AMD?

The AMD format comes from wanting a module format that was better than today's "write a bunch of script tags with implicit dependencies that you have to manually order" and something that was easy to use directly in the browser. Something with good debugging characteristics that did not require server-specific tooling to get started

+ Uses the CommonJS practice of string IDs for dependencies. Clear declaration of dependencies and avoids the use of globals.
+ IDs can be mapped to different paths. This allows swapping out implementation. This is great for creating mocks for unit testing.
+ Encapsulates the module definition. Gives you the tools to avoid polluting the global namespace.
+ Defines a way to include multiple modules in one file.
+ Allows setting a function as the return value. This is really useful for constructor functions.

---

### More details here:

+ [Official Require.js documentation](http://requirejs.org/)
+ ["JavaScript web applications" book](http://shop.oreilly.com/product/0636920018421.do)
+ [Using Backbone.js With Require.js](http://gregfranko.com/blog/using-backbone-dot-js-with-require-dot-js/)
